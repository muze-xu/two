# two

题目描述
小华现在有一个M*N的矩形，这M*N个矩形可以分割成M*N个等大的正方形，如下所示：
01—02—03—04
||　　||　　||　||
05—06—07—08
||　　||　　||　||
09—10—11—12
于是就有(M+1)*(N+1)个点，这些点都与相邻的点之间都有边，长度都为1，最左上角的点是1号，先按照每行依次递增，再按照列，如上图所示。
对于每个点，都有两种可行路径：
(1)向下走，用D表示
(2)向右走，用R表示

可以进行(1)向下(2)向右，从1点走到(M+1)*(N+1)点，此时小华添加了两个必要动作，首先给出动作的定义。
动作是指从某一点开始走一段规定的行进模式。
从1点到(M+1)*(N+1)点中必须出现小华给定的两个动作，例如：
01—02—03—04
||　　||　　||　||
05—06—07—08
||　　||　　||　||
09—10—11—12
小华说，必须要走这两个动作，(1)RRD和(2)DDR。
那么就一共有1种走法：RRDDR，简单的说，就是再也找不到其他的可行序列同时包含这两个串。
于是小华想知道，在必须出现这2种行进模式的情况下，从1号点走到(M+1)*(N+1)号点一共有多少种走法？

解答要求
时间限制：2000ms, 内存限制：128MB
输入
数据的第一行输入一个正整数T(1 <= T <= 10)，表示有T组测试数据。
每组测试数据的第一行输入两个正整数M, N(1 <= M, N <= 100)，M表示列数，N表示行数。
下面两行每行输入一个字符串，只包含“R”和“D”两种字符，长度不超过100，保证不会出现空串，并保证这两个串不会相同。

输出
对于每组测试数据，给出走法总数 MOD 1000000007的值。

样例
输入样例 1 复制

2
3 2
RRD
DDR
3 2
R
D
输出样例 1

1
10
提示样例 1


提示
AC自动机上的DP。
虽然只有2个串，但是仍然需要用AC自动机来表示划分状态，用AC自动机标记状态后，然后使用动态规划。
动态规划的状态是dp[M][N][st][2-bit]，其中M和N表示当前走到了第N行第M列，st表示的是当前的AC自动机状态，2-bit则是当前有了几个串，0表示1个串都没有，1表示有了第1个串，2表示有了第2个串，3表示2个串都出现了，那么只需根据自动机的转移，相应的转移到[M+1][N]和[M][N+1]的dp的状态即可，复杂度O(M * N * len(s))。
